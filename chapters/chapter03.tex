
In this section a description on how the code was built will be given. The focus used to build the code was a discipline in computer programming called test driven development, a description of what it is will be given. Version control system will be explained, what is a version control system and the elemental use of the version control system Git will be explained, which is used for interaction between different people that contribute to a single project. 


\section{Test Driven Development}
The idea of OOP goes well with a programming discipline test-driven development (TDD) which is being used more commonly. TDD is very similar to the concept of test first development (TDF) described by Kent Beck in his book ``Extreme programming'', and the main idea is to build a test to assert that the result from a small piece of the application code will be reached, this is very likely to make the programmer think of what is the result she wishes to obtain and very likely as consequence build a very efficient code. Usually a fundamental  step of TDF is described as ``write a test that will fail'', then under that idea build the functional part of the code that will make that test pass. Test driven development (TDD) follows this same idea, but adds an additional ingredient which is refactoring. In the book ``Test-driven development: an example'' Kent talks about a TDD ``mantra'' which is described in 3 simple steps, the first two are the same principles as the ones of TDF. The first step he calls it ``Red'' and says to write a small test that doesn't work, the second step ``Green'' is to make the test work (by writing the functional code), and the last step ``Refactor'' which is getting rid of all possible redundancies in the code without affecting the functional code $\cite{beck2003test}$. The testing is usually automated unit testing, the concept of unit testing is useful when using OOP, since the intention of OOP is to keep a clear and functional code with a certain degree of abstraction. Unit testing is testing each small component of a program. It is important to say that TDD is intended to test the code in small steps, and not the final application of the code. So in TDD testing and designing the code go together in small steps to produce a final simple and testable code. 

\begin{figure}[h]
\begin{center}
	\includegraphics[scale=0.35]{TDD}

\caption{Basic TDD diagram.}
\label{tab:tdddiag}
\end{center}
\end{figure}

For testing in this code $\textbf{unittest}$ test module contained in the standard Python library was used. $\textbf{unittest}$ from Python supports some important concepts for testing for example test fixture, test case, test suite and test runner $\cite{van2003python}$. For the code given that each function of each module was tested we used the smallest unit for testing which is the class $\textbf{TestCase}$. Although there exist many methods for testing in $\textbf{TestCase}$,  for this code the main methods used when testing were the following (taken from van Rossum 2003$\cite{van2003python}$):

\begin{itemize}
	\item $\textbf{assertEqual:}$ Asserts an element a is equal to an element  b (a == b) if the values are not equal the test fails.
	\item $\textbf{assertNotEqual:}$ Asserts an element a is not equal to an element b (a !=b) if the values are equal the test fails.
	\item $\textbf{assertTrue:}$ Asserts an argument passed is True (bool(x) is True) test fails if argument is not True. 
	\item $\textbf{assertFalse:}$ Asserts an argument passed is False (bool(x) is False) test fails if argument is not False.
	\item $\textbf{assertIn:}$ Assert an element a is contained in b (a in b) test fails if the element a is not part of b (i.e. a = 3, and b = [1, 5, 6, 8 ,10], value of a (3) is not contained in the list so the test fails).
\end{itemize}

\section{Version Control}
When teaming with other people with common goals for developing any kind of project, one of the most important elements is communication. There should be a common agreement for a communication channel so every element of the team can be updated with any changes made during the project. 
Developing a project in computer programming is not the exception, and from some years back computer programmers have been using very efficient communication channels. Some very  useful tool are version control systems (VCS). The main goal from a VCS is to keep track of the development of a project with a very intelligent system that allows people (programmers) to track changes in a project through time. It keeps record of changes that have been made to a project and allows to retrieve the information from those other points in time. VCS basically can create a backups for every changes made to a project, revert specific files, the whole project to a previous state, compare changes over time, see who did last modifications that could be causing a problem, who introduced an issue, when among other $\cite{chacon2009pro}$. Version controlled systems can be local, centralized or distributed, to collaborate in a project nowadays the most popular and perhaps effective choice is to use distributed version control systems in which the users fully mirror the set of files or directories under version control commonly known as `repository' $\cite{chacon2009pro}$. This means that each contributor has a copy of the full repository and if the main server has a malfunction and information is lost, it can be restored by any contributor. 

The VCS used for this project was Git. Git was authored and developed by the creator of Linux kernel, Linus Trovalds in 2005 and many other developers from the Linux community after a commercial, break down between the community that developed Linux kernel and the company that provided them DVCS called BitKeeper $\cite{chacon2009pro}$ . 

Git thinks of data like snapshots of a miniature filesystem, to take this snapshots Git has a command that is called commit which can be used to record in different points of time. One could think of commits as some form of milestones for the individual and the collective part of the project. An important fact about Git is that since all the history of the project being developed is in each users local disk, the speed to browse around the history of the project is very efficient. This also allows the user to work even if there is no access to the network where the repository is. 

For this project only basic, but still essential features of Git were used. The webpage where the repository for the project was stored is Github, a link to the code can be found in appendix $\ref{app:codemodules}$. For using Github, first one has to create a user name and then a repository in the webpage . Which is relatively easy by following the instructions given in the webpage. It essentially asks to give a name to the repository and an optional description, the repository can be public or private, for this project it was set as public. It is advisable to create a README file for describing the project. At the end of the steps one selects create repository and the repository is created. Setting up Git in the pc is not hard, for this Git bash was used which is a built environment shell for Windows and enables Windows to use the Git commands.
There is a lot of information about how to set up Git bash in the web which involves generating a key, by adding a command in bash along with which I added the email address used when signing up in Github in this case and then follow the steps and it is set. 
To start working with a repository from Github either our own or someone else's. We copy an URL that appears on the right bar in the page from the repository we intend to work with. 
This URL was pasted into the Git bash  in the same line after the following command $\textbf{git clone}$ and with this a local clone of the repository is created.
Once the local directory for the project is in the pc, we can start working with it. Every file that will be included in the project should be in that directory. To see the basic Git commands with a short description used for this project go to appendix $\ref{app:gitcommands}$ Git Commands. If further information is required a link to Github can be found in appendix $\ref{app:gitcommands}$.

\section{Documentation}

A good practice when creating a package is to put together $\textbf{Documentation}$ about it. The $\textbf{Documentation}$ must contain relevant information about the package and how to use it. The $\textbf{Documentation}$ for this package can be found in:  \url{http://agent-based-learning.readthedocs.org/en/latest/}, and as it can be seen from the link it is held in a very useful webpage for sharing information and particularly documentation from packages called \url{http://readthedocs.org} $\textbf{Read the Docs}$. An advantage of using $\textbf{ReadTheDocs}$ is that it can be linked to a $\textbf{GitHub}$ repository, and it can be set to automatically update whenever new information from the repository is available.  To be able to build a correct structure that could be used by $\textbf{Read the Docs}$ a tool named  $\textbf{Sphinx}$ was used. $\textbf{Sphinx}$ is a tool that was originally designed to help create documentation for Python, and now it can be used for other languages. It helps to create basic files to give the initial structure to the $\textbf{Documentation}$, by building an index which acts as the main view for the $\textbf{Documentation}$. After this as many number of .rst files can be created, as required to populate the $\textbf{Documentation}$ file. It is recommended to create a directory with the name of $\textbf{docs}$ or $\textbf{doc}$ that will hold the files created and all the additional files the user creates to be included in the documentation. An .rst is the extension  for  $\textbf{reStructuredText}$. A $\textbf{reStructuredText}$ is a markup syntax that is useful for doing inline program documentation, webpages designs and simple text documents $\cite{docutils:2015}$. The files created can contain any kind of information, and by referencing the created file in the index it automatically generates it as a $\textbf{section}$ of the $\textbf{Documentation}$. 
The  $\textbf{Documentation}$ for this package was built using the format previously mentioned $\textbf{reStructuredText}$ (rst), the name given to the $\textbf{Documentation}$ directory was $\textbf{docs}$. After creating a basic structure, the directory was pushed to a branch in $\textbf{GitHub}$, and when the branch was merged with the master branch, the changes made automatically updated the $\textbf{ReadTheDocs}$ page for the $\textbf{Documentation}$. The result is a nice looking and readable output that is relatively easy to understand $\cite{docutils:2015}$. 
